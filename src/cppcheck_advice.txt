coast.h:124:8: style:inconclusive: The member function 'CRWCoast::nGetCoastPointGivenCell' can be made a const function. Making this function 'const' should not cause compiler errors. Even though the function can be made const function technically it may not make sense conceptually. Think about your design and the task of the function first - is it a function that must not change object internal state? [functionConst]
   int nGetCoastPointGivenCell(CGeom2DIPoint *);
       ^
coast.cpp:198:15: note: Technically the member function 'CRWCoast::nGetCoastPointGivenCell' can be const.
int CRWCoast::nGetCoastPointGivenCell(CGeom2DIPoint *pPtiCell)
              ^
coast.h:124:8: note: Technically the member function 'CRWCoast::nGetCoastPointGivenCell' can be const.
   int nGetCoastPointGivenCell(CGeom2DIPoint *);
       ^
coast.h:201:8: style:inconclusive: The member function 'CRWCoast::nGetNumShadowBoundaries' can be made a const function. Making this function 'const' should not cause compiler errors. Even though the function can be made const function technically it may not make sense conceptually. Think about your design and the task of the function first - is it a function that must not change object internal state? [functionConst]
   int nGetNumShadowBoundaries(void);
       ^
coast.cpp:614:15: note: Technically the member function 'CRWCoast::nGetNumShadowBoundaries' can be const.
int CRWCoast::nGetNumShadowBoundaries(void)
              ^
coast.h:201:8: note: Technically the member function 'CRWCoast::nGetNumShadowBoundaries' can be const.
   int nGetNumShadowBoundaries(void);
       ^
coast.h:205:8: style:inconclusive: The member function 'CRWCoast::nGetNumShadowDowndriftBoundaries' can be made a const function. Making this function 'const' should not cause compiler errors. Even though the function can be made const function technically it may not make sense conceptually. Think about your design and the task of the function first - is it a function that must not change object internal state? [functionConst]
   int nGetNumShadowDowndriftBoundaries(void);
       ^
coast.cpp:630:15: note: Technically the member function 'CRWCoast::nGetNumShadowDowndriftBoundaries' can be const.
int CRWCoast::nGetNumShadowDowndriftBoundaries(void)
              ^
coast.h:205:8: note: Technically the member function 'CRWCoast::nGetNumShadowDowndriftBoundaries' can be const.
   int nGetNumShadowDowndriftBoundaries(void);
       ^
create_profiles.cpp:1637:56: error: Invalid pVIPointsOut->at() argument nr 1. The value is -1 but the valid values are '0:'. [invalidFunctionArg]
         nLastX = pVIPointsOut->at(pVIPointsOut->size()-1).nGetX(),
                                                       ^
create_profiles.cpp:1638:56: error: Invalid pVIPointsOut->at() argument nr 1. The value is -1 but the valid values are '0:'. [invalidFunctionArg]
         nLastY = pVIPointsOut->at(pVIPointsOut->size()-1).nGetY();
                                                       ^
create_profiles.cpp:1653:424: error: Invalid pVIPointsOut->at() argument nr 1. The value is -1 but the valid values are '0:'. [invalidFunctionArg]
         LogStream << m_ulIter << ": profile " << nProfile << " is invalid, is too short, only " << pVIPointsOut->size() << " points, HitLand?" << bHitLand << ". From [" << pVIPointsOut->at(0).nGetX() << "][" << pVIPointsOut->at(0).nGetY() << "] = {" << dGridCentroidXToExtCRSX(pVIPointsOut->at(0).nGetX()) << ", " << dGridCentroidYToExtCRSY(pVIPointsOut->at(0).nGetY()) << "} to [" << pVIPointsOut->at(pVIPointsOut->size()-1).nGetX() << "][" << pVIPointsOut->at(pVIPointsOut->size()-1).nGetY() << "] = {" << dGridCentroidXToExtCRSX(pVIPointsOut->at(pVIPointsOut->size()-1).nGetX()) << ", " << dGridCentroidYToExtCRSY(pVIPointsOut->at(pVIPointsOut->size()-1).nGetY()) << "}" << endl;
                                                                                                                                                                                                                                                                                                                                                                                                                                       ^
create_profiles.cpp:1324:85: style: Condition 'bHitLand' is always false [knownConditionTrueFalse]
         if ((bTruncated && (! ACCEPT_SHORT_PROFILES)) || bTooShort || bHitCoast || bHitLand || bHitAnotherProfile)
                                                                                    ^
create_profiles.cpp:1319:34: note: Assignment 'bHitLand=false', assigned value is 0
            bHitLand           = false,
                                 ^
create_profiles.cpp:1324:85: note: Condition 'bHitLand' is always false
         if ((bTruncated && (! ACCEPT_SHORT_PROFILES)) || bTooShort || bHitCoast || bHitLand || bHitAnotherProfile)
                                                                                    ^
create_profiles.cpp:1644:29: style: Condition 'pVIPointsOut->size()<3' is always true [knownConditionTrueFalse]
   if (pVIPointsOut->size() < 3)
                            ^
create_profiles.cpp:1637:35: error: Out of bounds access in expression 'pVIPointsOut->at(pVIPointsOut->size()-1)' because 'pVIPointsOut' is empty and 'at' may be non-zero. [containerOutOfBounds]
         nLastX = pVIPointsOut->at(pVIPointsOut->size()-1).nGetX(),
                                  ^
create_profiles.cpp:1638:35: error: Out of bounds access in expression 'pVIPointsOut->at(pVIPointsOut->size()-1)' because 'pVIPointsOut' is empty and 'at' may be non-zero. [containerOutOfBounds]
         nLastY = pVIPointsOut->at(pVIPointsOut->size()-1).nGetY();
                                  ^
create_profiles.cpp:1653:190: error: Out of bounds access in expression 'pVIPointsOut->at(0)' because 'pVIPointsOut' is empty and 'at' may be non-zero. [containerOutOfBounds]
         LogStream << m_ulIter << ": profile " << nProfile << " is invalid, is too short, only " << pVIPointsOut->size() << " points, HitLand?" << bHitLand << ". From [" << pVIPointsOut->at(0).nGetX() << "][" << pVIPointsOut->at(0).nGetY() << "] = {" << dGridCentroidXToExtCRSX(pVIPointsOut->at(0).nGetX()) << ", " << dGridCentroidYToExtCRSY(pVIPointsOut->at(0).nGetY()) << "} to [" << pVIPointsOut->at(pVIPointsOut->size()-1).nGetX() << "][" << pVIPointsOut->at(pVIPointsOut->size()-1).nGetY() << "] = {" << dGridCentroidXToExtCRSX(pVIPointsOut->at(pVIPointsOut->size()-1).nGetX()) << ", " << dGridCentroidYToExtCRSY(pVIPointsOut->at(pVIPointsOut->size()-1).nGetY()) << "}" << endl;
                                                                                                                                                                                             ^
create_profiles.cpp:1653:403: error: Out of bounds access in expression 'pVIPointsOut->at(pVIPointsOut->size()-1)' because 'pVIPointsOut' is empty and 'at' may be non-zero. [containerOutOfBounds]
         LogStream << m_ulIter << ": profile " << nProfile << " is invalid, is too short, only " << pVIPointsOut->size() << " points, HitLand?" << bHitLand << ". From [" << pVIPointsOut->at(0).nGetX() << "][" << pVIPointsOut->at(0).nGetY() << "] = {" << dGridCentroidXToExtCRSX(pVIPointsOut->at(0).nGetX()) << ", " << dGridCentroidYToExtCRSY(pVIPointsOut->at(0).nGetY()) << "} to [" << pVIPointsOut->at(pVIPointsOut->size()-1).nGetX() << "][" << pVIPointsOut->at(pVIPointsOut->size()-1).nGetY() << "] = {" << dGridCentroidXToExtCRSX(pVIPointsOut->at(pVIPointsOut->size()-1).nGetX()) << ", " << dGridCentroidYToExtCRSY(pVIPointsOut->at(pVIPointsOut->size()-1).nGetY()) << "}" << endl;
                                                                                                                                                                                                                                                                                                                                                                                                                  ^
sediment_input_event.h:45:8: style:inconclusive: The member function 'CSedInputEvent::nGetLocationID' can be made a const function. Making this function 'const' should not cause compiler errors. Even though the function can be made const function technically it may not make sense conceptually. Think about your design and the task of the function first - is it a function that must not change object internal state? [functionConst]
   int nGetLocationID(void);
       ^
sediment_input_event.cpp:47:21: note: Technically the member function 'CSedInputEvent::nGetLocationID' can be const.
int CSedInputEvent::nGetLocationID(void)
                    ^
sediment_input_event.h:45:8: note: Technically the member function 'CSedInputEvent::nGetLocationID' can be const.
   int nGetLocationID(void);
       ^
sediment_input_event.h:46:18: style:inconclusive: The member function 'CSedInputEvent::ulGetEventTimeStep' can be made a const function. Making this function 'const' should not cause compiler errors. Even though the function can be made const function technically it may not make sense conceptually. Think about your design and the task of the function first - is it a function that must not change object internal state? [functionConst]
   unsigned long ulGetEventTimeStep(void);
                 ^
sediment_input_event.cpp:52:31: note: Technically the member function 'CSedInputEvent::ulGetEventTimeStep' can be const.
unsigned long CSedInputEvent::ulGetEventTimeStep(void)
                              ^
sediment_input_event.h:46:18: note: Technically the member function 'CSedInputEvent::ulGetEventTimeStep' can be const.
   unsigned long ulGetEventTimeStep(void);
                 ^
sediment_input_event.h:47:11: style:inconclusive: The member function 'CSedInputEvent::dGetFineSedVol' can be made a const function. Making this function 'const' should not cause compiler errors. Even though the function can be made const function technically it may not make sense conceptually. Think about your design and the task of the function first - is it a function that must not change object internal state? [functionConst]
   double dGetFineSedVol(void);
          ^
sediment_input_event.cpp:57:24: note: Technically the member function 'CSedInputEvent::dGetFineSedVol' can be const.
double CSedInputEvent::dGetFineSedVol(void)
                       ^
sediment_input_event.h:47:11: note: Technically the member function 'CSedInputEvent::dGetFineSedVol' can be const.
   double dGetFineSedVol(void);
          ^
sediment_input_event.h:48:11: style:inconclusive: The member function 'CSedInputEvent::dGetSandSedVol' can be made a const function. Making this function 'const' should not cause compiler errors. Even though the function can be made const function technically it may not make sense conceptually. Think about your design and the task of the function first - is it a function that must not change object internal state? [functionConst]
   double dGetSandSedVol(void);
          ^
sediment_input_event.cpp:62:24: note: Technically the member function 'CSedInputEvent::dGetSandSedVol' can be const.
double CSedInputEvent::dGetSandSedVol(void)
                       ^
sediment_input_event.h:48:11: note: Technically the member function 'CSedInputEvent::dGetSandSedVol' can be const.
   double dGetSandSedVol(void);
          ^
sediment_input_event.h:49:11: style:inconclusive: The member function 'CSedInputEvent::dGetCoarseSedVol' can be made a const function. Making this function 'const' should not cause compiler errors. Even though the function can be made const function technically it may not make sense conceptually. Think about your design and the task of the function first - is it a function that must not change object internal state? [functionConst]
   double dGetCoarseSedVol(void);
          ^
sediment_input_event.cpp:67:24: note: Technically the member function 'CSedInputEvent::dGetCoarseSedVol' can be const.
double CSedInputEvent::dGetCoarseSedVol(void)
                       ^
sediment_input_event.h:49:11: note: Technically the member function 'CSedInputEvent::dGetCoarseSedVol' can be const.
   double dGetCoarseSedVol(void);
          ^
sediment_input_event.h:50:11: style:inconclusive: The member function 'CSedInputEvent::dGetLen' can be made a const function. Making this function 'const' should not cause compiler errors. Even though the function can be made const function technically it may not make sense conceptually. Think about your design and the task of the function first - is it a function that must not change object internal state? [functionConst]
   double dGetLen(void);
          ^
sediment_input_event.cpp:72:24: note: Technically the member function 'CSedInputEvent::dGetLen' can be const.
double CSedInputEvent::dGetLen(void)
                       ^
sediment_input_event.h:50:11: note: Technically the member function 'CSedInputEvent::dGetLen' can be const.
   double dGetLen(void);
          ^
sediment_input_event.h:51:11: style:inconclusive: The member function 'CSedInputEvent::dGetWidth' can be made a const function. Making this function 'const' should not cause compiler errors. Even though the function can be made const function technically it may not make sense conceptually. Think about your design and the task of the function first - is it a function that must not change object internal state? [functionConst]
   double dGetWidth(void);
          ^
sediment_input_event.cpp:77:24: note: Technically the member function 'CSedInputEvent::dGetWidth' can be const.
double CSedInputEvent::dGetWidth(void)
                       ^
sediment_input_event.h:51:11: note: Technically the member function 'CSedInputEvent::dGetWidth' can be const.
   double dGetWidth(void);
          ^
shore_platform.cpp:62:22: error: AST broken, ternary operator missing operand(s) [internalAstError]
      for ((bForward ? nProfile = 0 : nProfile = (nNumProfiles-1)); (bForward ? nProfile < nNumProfiles : nProfile >= 0); (bForward ? nProfile++ : nProfile--))
                     ^
simulation.cpp:202:4: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'm_GDALWriteIntDataType' a value by passing the value to the constructor in the initialization list. [useInitializationList]
   m_GDALWriteIntDataType                          =
   ^
simulation.cpp:203:4: performance: When an object of a class is created, the constructors of all member variables are called consecutively in the order the variables are declared, even if you don't explicitly write them to the initialization list. You could avoid assigning 'm_GDALWriteFloatDataType' a value by passing the value to the constructor in the initialization list. [useInitializationList]
   m_GDALWriteFloatDataType                        = GDT_Unknown;
   ^
simulation.h:561:9: style:inconclusive: The member function 'CSimulation::nSaveProfile' can be made a const function. Making this function 'const' should not cause compiler errors. Even though the function can be made const function technically it may not make sense conceptually. Think about your design and the task of the function first - is it a function that must not change object internal state? [functionConst]
    int nSaveProfile(int const, int const, int const, vector<double> const *, vector<double> const *, vector<double> const *, vector<double> const *, vector<double> const *, vector<double> const *, vector<double> const *, vector<CGeom2DIPoint> *const, vector<double> const *);
        ^
write_output.cpp:916:18: note: Technically the member function 'CSimulation::nSaveProfile' can be const.
int CSimulation::nSaveProfile(int const nProfile, int const nCoast, int const nProfSize, vector<double> const* pdVDistXY, vector<double> const* pdVZ, vector<double> const* pdVDepthOverDB, vector<double> const* pdVErosionPotentialFunc, vector<double> const* pdVSlope, vector<double> const* pdVRecessionXY, vector<double> const* pdVChangeElevZ, vector<CGeom2DIPoint>* const pPtVGridProfile, vector<double> const* pdVScapeXY)
                 ^
simulation.h:561:9: note: Technically the member function 'CSimulation::nSaveProfile' can be const.
    int nSaveProfile(int const, int const, int const, vector<double> const *, vector<double> const *, vector<double> const *, vector<double> const *, vector<double> const *, vector<double> const *, vector<double> const *, vector<CGeom2DIPoint> *const, vector<double> const *);
        ^
simulation.h:563:9: style:inconclusive: The member function 'CSimulation::nSaveParProfile' can be made a const function. Making this function 'const' should not cause compiler errors. Even though the function can be made const function technically it may not make sense conceptually. Think about your design and the task of the function first - is it a function that must not change object internal state? [functionConst]
    int nSaveParProfile(int const, int const, int const, int const, int const, vector<double> const *, vector<double> const *, vector<double> const *, vector<double> const *, vector<double> const *, vector<double> const *, vector<double> const *, vector<CGeom2DIPoint> *const, vector<double> const *);
        ^
write_output.cpp:986:18: note: Technically the member function 'CSimulation::nSaveParProfile' can be const.
int CSimulation::nSaveParProfile(int const nProfile, int const nCoast, int const nParProfSize, int const nDirection, int const nDistFromProfile, vector<double> const* pdVDistXY, vector<double> const* pdVZ, vector<double> const* pdVDepthOverDB, vector<double> const* pdVErosionPotentialFunc, vector<double> const* pdVSlope, vector<double> const* pdVRecessionXY, vector<double> const* pdVChangeElevZ, vector<CGeom2DIPoint>* const pPtVGridProfile, vector<double> const* pdVScapeXY)
                 ^
simulation.h:563:9: note: Technically the member function 'CSimulation::nSaveParProfile' can be const.
    int nSaveParProfile(int const, int const, int const, int const, int const, vector<double> const *, vector<double> const *, vector<double> const *, vector<double> const *, vector<double> const *, vector<double> const *, vector<double> const *, vector<CGeom2DIPoint> *const, vector<double> const *);
        ^
coast.cpp:110:0: style: The function 'AppendPointToCoastlineExtCRS' is never used. [unusedFunction]

^
calc_waves.cpp:1597:0: style: The function 'CShoreHermiteSmoothing' is never used. [unusedFunction]

^
2d_shape.cpp:44:0: style: The function 'Clear' is never used. [unusedFunction]

^
cliff.cpp:133:0: style: The function 'Display' is never used. [unusedFunction]

^
gis_utils.cpp:1669:0: style: The function 'GetSlopeAndInterceptFromPoints' is never used. [unusedFunction]

^
gis_utils.cpp:449:0: style: The function 'PtiAverage' is never used. [unusedFunction]

^
cell.cpp:545:0: style: The function 'SetActualPlatformErosion' is never used. [unusedFunction]

^
cell.cpp:690:0: style: The function 'SetBeachProtectionFactor' is never used. [unusedFunction]

^
profile.cpp:83:0: style: The function 'SetHitLand' is never used. [unusedFunction]

^
cell.cpp:261:0: style: The function 'SetLocalConsSlope' is never used. [unusedFunction]

^
cell.cpp:526:0: style: The function 'SetPotentialPlatformErosion' is never used. [unusedFunction]

^
linearinterp.cpp:46:0: style: The function 'VdInterp1' is never used. [unusedFunction]

^
utils.cpp:2790:0: style: The function 'bIsNumeric' is never used. [unusedFunction]

^
cell.cpp:414:0: style: The function 'bIsSeaIncBeach' is never used. [unusedFunction]

^
utils.cpp:2582:0: style: The function 'dCrossProduct' is never used. [unusedFunction]

^
coast.cpp:426:0: style: The function 'dGetCoastDeepWaterWaveHeight' is never used. [unusedFunction]

^
coast.cpp:307:0: style: The function 'dGetDetailedCurvatureMean' is never used. [unusedFunction]

^
coast.cpp:317:0: style: The function 'dGetDetailedCurvatureSTD' is never used. [unusedFunction]

^
utils.cpp:2594:0: style: The function 'dGetMean' is never used. [unusedFunction]

^
utils.cpp:2607:0: style: The function 'dGetStdDev' is never used. [unusedFunction]

^
coast.cpp:553:0: style: The function 'dGetWaveEnergyatBreaking' is never used. [unusedFunction]

^
smooth_line.cpp:296:0: style: The function 'dVSmoothProfileSlope' is never used. [unusedFunction]

^
multi_line.cpp:268:0: style: The function 'nFindProfilesLastSeg' is never used. [unusedFunction]

^
write_output.cpp:986:0: style: The function 'nSaveParProfile' is never used. [unusedFunction]

^
write_output.cpp:916:0: style: The function 'nSaveProfile' is never used. [unusedFunction]

^
line.cpp:69:0: style: The function 'pPtGetAt' is never used. [unusedFunction]

^
i_line.cpp:44:0: style: The function 'pPtiGetAt' is never used. [unusedFunction]

^
utils.cpp:2411:0: style: The function 'pstrChangeToBackslash' is never used. [unusedFunction]

^
utils.cpp:2424:0: style: The function 'pstrChangeToForwardSlash' is never used. [unusedFunction]

^
